/**
 * MIT License
 *
 * Copyright (c) 2025 Takatoshi Kondo
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
use std::time::Instant;

use multi_index_map::MultiIndexMap;
use tracing::trace;

use crate::mqtt::value_allocator::ValueAllocator;

/// Type alias for topic alias values
pub type TopicAliasType = u16;

/// Entry for topic alias mapping
#[derive(MultiIndexMap, Debug, Clone)]
struct Entry {
    #[multi_index(hashed_unique)]
    alias: TopicAliasType,
    #[multi_index(hashed_unique)]
    topic: String,
    #[multi_index(ordered_non_unique)]
    timestamp: Instant,
}

impl Entry {
    fn new(topic: String, alias: TopicAliasType) -> Self {
        Self {
            topic,
            alias,
            timestamp: Instant::now(),
        }
    }

    fn touch(&mut self) {
        self.timestamp = Instant::now();
    }
}

/// Topic alias manager for sending MQTT packets
///
/// This manages the mapping between topic names and numeric aliases for outgoing
/// MQTT PUBLISH packets to reduce packet size for frequently used topics.
pub struct TopicAliasSend {
    max_alias: TopicAliasType,
    // MultiIndexEntryMap generated by the derive macro
    aliases: MultiIndexEntryMap,
    value_allocator: ValueAllocator<TopicAliasType>,
}

impl TopicAliasSend {
    const MIN_ALIAS: TopicAliasType = 1;

    /// Create a new TopicAliasSend with the specified maximum alias value
    pub fn new(max_alias: TopicAliasType) -> Self {
        trace!("Creating TopicAliasSend with max_alias: {}", max_alias);

        Self {
            max_alias,
            aliases: MultiIndexEntryMap::default(),
            value_allocator: ValueAllocator::new(Self::MIN_ALIAS, max_alias),
        }
    }

    /// Insert or update a topic-alias mapping
    ///
    /// # Arguments
    /// * `topic` - The topic name (must not be empty)
    /// * `alias` - The alias value (must be between MIN_ALIAS and max_alias)
    ///
    /// # Panics
    /// Panics if topic is empty or alias is out of valid range
    pub fn insert_or_update(&mut self, topic: &str, alias: TopicAliasType) {
        trace!("TopicAliasSend insert topic: '{}', alias: {}", topic, alias);

        assert!(!topic.is_empty() && alias >= Self::MIN_ALIAS && alias <= self.max_alias);

        // Mark this alias as used in the value allocator
        self.value_allocator.use_value(alias);

        // Remove existing entry with same alias if it exists
        self.aliases.remove_by_alias(&alias);

        // Remove existing entry with same topic if it exists
        self.aliases.remove_by_topic(&topic.to_string());

        // Insert new entry
        let entry = Entry::new(topic.to_string(), alias);
        self.aliases.insert(entry);
    }

    /// Get topic by alias and update access timestamp (affects LRU)
    ///
    /// # Arguments
    /// * `alias` - The alias to look up
    ///
    /// # Returns
    /// The topic name if found, None otherwise
    pub fn get(&mut self, alias: TopicAliasType) -> Option<&str> {
        trace!("Getting topic by alias: {}", alias);

        if alias >= Self::MIN_ALIAS && alias <= self.max_alias {
            if let Some(entry_ref) = self.aliases.modify_by_alias(&alias, |entry| {
                entry.touch();
            }) {
                return Some(&entry_ref.topic);
            }
        }
        None
    }

    /// Peek topic by alias without updating access timestamp (does not affect LRU)
    ///
    /// # Arguments
    /// * `alias` - The alias to look up
    ///
    /// # Returns
    /// The topic name if found, None otherwise
    pub fn peek(&self, alias: TopicAliasType) -> Option<&str> {
        trace!("Peeking topic by alias (no touch): {}", alias);

        if alias >= Self::MIN_ALIAS && alias <= self.max_alias {
            if let Some(entry) = self.aliases.get_by_alias(&alias) {
                return Some(&entry.topic);
            }
        }
        None
    }

    /// Find alias by topic name
    ///
    /// # Arguments
    /// * `topic` - The topic name to look up
    ///
    /// # Returns
    /// The alias if found, None otherwise
    pub fn find_by_topic(&self, topic: &str) -> Option<TopicAliasType> {
        trace!("Finding alias by topic: '{}'", topic);

        self.aliases
            .get_by_topic(&topic.to_string())
            .map(|entry| entry.alias)
    }

    /// Clear all topic-alias mappings
    pub fn clear(&mut self) {
        trace!("Clearing all topic aliases");
        self.aliases.clear();
        self.value_allocator.clear();
    }

    /// Get the least recently used (LRU) alias
    ///
    /// Returns either the first vacant alias or the oldest used alias
    ///
    /// # Returns
    /// An alias value that can be reused
    ///
    /// # Panics
    /// Panics if max_alias is 0
    pub fn get_lru_alias(&self) -> TopicAliasType {
        assert!(self.max_alias > 0);

        // First try to get a vacant alias
        if let Some(alias) = self.value_allocator.first_vacant() {
            return alias;
        }

        // If no vacant aliases, return the least recently used one
        self.aliases
            .iter()
            .min_by_key(|(_, entry)| entry.timestamp)
            .map(|(_, entry)| entry.alias)
            .unwrap_or(Self::MIN_ALIAS)
    }

    /// Get the maximum alias value
    pub fn max(&self) -> TopicAliasType {
        self.max_alias
    }
}
